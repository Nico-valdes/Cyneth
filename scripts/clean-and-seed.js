const { connectToDatabase } = require('../src/libs/mongoConnect');
const { ObjectId } = require('mongodb');

/**
 * SCRIPT DE LIMPIEZA Y SEEDING
 * 
 * Limpia completamente la base de datos y crea una estructura 
 * de categor√≠as limpia y bien organizada para empezar desde cero
 */

async function cleanAndSeed() {
  let client = null;
  
  try {
    console.log('üîå Conectando a MongoDB...');
    client = await connectToDatabase();
    const db = client.db('cyneth');
    
    console.log('\nüßπ LIMPIEZA Y SEEDING DE BASE DE DATOS\n');
    
    // 1. BACKUP DE DATOS ACTUALES
    console.log('üì¶ Creando backup de datos actuales...');
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    
    try {
      const categories = await db.collection('categories').find({}).toArray();
      const products = await db.collection('products').find({}).toArray();
      
      if (categories.length > 0) {
        await db.collection(`categories_backup_${timestamp}`).insertMany(categories);
        console.log(`   ‚úÖ ${categories.length} categor√≠as respaldadas`);
      }
      
      if (products.length > 0) {
        await db.collection(`products_backup_${timestamp}`).insertMany(products);
        console.log(`   ‚úÖ ${products.length} productos respaldados`);
      }
    } catch (error) {
      console.log('   ‚ö†Ô∏è  Error en backup (continuando):', error.message);
    }
    
    // 2. LIMPIAR COLECCIONES
    console.log('\nüóëÔ∏è  Limpiando colecciones...');
    
    await db.collection('categories').deleteMany({});
    await db.collection('products').deleteMany({});
    
    // Tambi√©n limpiar subcategories si existe
    try {
      await db.collection('subcategories').deleteMany({});
    } catch (error) {
      // No importa si no existe
    }
    
    console.log('   ‚úÖ Colecciones limpiadas');
    
    // 3. CREAR ESTRUCTURA DE CATEGOR√çAS LIMPIA
    console.log('\nüèóÔ∏è  Creando estructura de categor√≠as...');
    
    // Estructura jer√°rquica limpia para un cat√°logo de plomer√≠a/grifer√≠a
    const categoryStructure = [
      {
        name: 'Grifer√≠a',
        slug: 'griferia',
        description: 'Grifos, canillas y accesorios',
        children: [
          {
            name: 'Ba√±o',
            slug: 'griferia-bano',
            description: 'Grifer√≠a para ba√±o',
            children: [
              {
                name: 'Monocomando',
                slug: 'griferia-bano-monocomando',
                description: 'Grifos de una sola palanca',
                children: [
                  { name: 'Lavatorio', slug: 'griferia-bano-monocomando-lavatorio' },
                  { name: 'Bidet', slug: 'griferia-bano-monocomando-bidet' },
                  { name: 'Ducha', slug: 'griferia-bano-monocomando-ducha' },
                  { name: 'Ba√±era', slug: 'griferia-bano-monocomando-banera' }
                ]
              },
              {
                name: 'Doble Comando',
                slug: 'griferia-bano-doble-comando',
                description: 'Grifos de dos palancas',
                children: [
                  { name: 'Lavatorio', slug: 'griferia-bano-doble-comando-lavatorio' },
                  { name: 'Bidet', slug: 'griferia-bano-doble-comando-bidet' },
                  { name: 'Ducha', slug: 'griferia-bano-doble-comando-ducha' }
                ]
              }
            ]
          },
          {
            name: 'Cocina',
            slug: 'griferia-cocina',
            description: 'Grifer√≠a para cocina',
            children: [
              { name: 'Monocomando', slug: 'griferia-cocina-monocomando' },
              { name: 'Doble Comando', slug: 'griferia-cocina-doble-comando' },
              { name: 'Con Filtro', slug: 'griferia-cocina-con-filtro' }
            ]
          },
          {
            name: 'Ducha',
            slug: 'griferia-ducha',
            description: 'Grifer√≠a para ducha',
            children: [
              { name: 'Monocomando', slug: 'griferia-ducha-monocomando' },
              { name: 'Termost√°tica', slug: 'griferia-ducha-termostatica' },
              { name: 'Empotrable', slug: 'griferia-ducha-empotrable' }
            ]
          }
        ]
      },
      {
        name: 'Plomer√≠a',
        slug: 'plomeria',
        description: 'Tuber√≠as, conexiones y accesorios',
        children: [
          {
            name: 'Tuber√≠as',
            slug: 'plomeria-tuberias',
            children: [
              { name: 'PVC', slug: 'plomeria-tuberias-pvc' },
              { name: 'Cobre', slug: 'plomeria-tuberias-cobre' },
              { name: 'PPR', slug: 'plomeria-tuberias-ppr' }
            ]
          },
          {
            name: 'Conexiones',
            slug: 'plomeria-conexiones',
            children: [
              { name: 'Codos', slug: 'plomeria-conexiones-codos' },
              { name: 'T√©s', slug: 'plomeria-conexiones-tes' },
              { name: 'Uniones', slug: 'plomeria-conexiones-uniones' }
            ]
          }
        ]
      },
      {
        name: 'Sanitarios',
        slug: 'sanitarios',
        description: 'Inodoros, lavatorios y bidets',
        children: [
          { name: 'Inodoros', slug: 'sanitarios-inodoros' },
          { name: 'Lavatorios', slug: 'sanitarios-lavatorios' },
          { name: 'Bidets', slug: 'sanitarios-bidets' },
          { name: 'Accesorios', slug: 'sanitarios-accesorios' }
        ]
      },
      {
        name: 'Calefacci√≥n',
        slug: 'calefaccion',
        description: 'Sistemas de calefacci√≥n',
        children: [
          { name: 'Radiadores', slug: 'calefaccion-radiadores' },
          { name: 'Calderas', slug: 'calefaccion-calderas' },
          { name: 'Accesorios', slug: 'calefaccion-accesorios' }
        ]
      }
    ];
    
    // Funci√≥n recursiva para insertar categor√≠as
    async function insertCategories(categories, parent = null, level = 0) {
      for (const category of categories) {
        const categoryDoc = {
          _id: new ObjectId(),
          name: category.name,
          slug: category.slug,
          description: category.description || '',
          parent: parent,
          level: level,
          type: level === 0 ? 'main' : 'sub',
          productCount: 0,
          totalProductCount: 0,
          order: 0,
          active: true,
          createdAt: new Date(),
          updatedAt: new Date()
        };
        
        const result = await db.collection('categories').insertOne(categoryDoc);
        console.log(`   ${'  '.repeat(level)}‚úÖ ${category.name} (level ${level})`);
        
        // Insertar hijos recursivamente
        if (category.children && category.children.length > 0) {
          await insertCategories(category.children, result.insertedId, level + 1);
        }
      }
    }
    
    await insertCategories(categoryStructure);
    
    // 4. CREAR ALGUNOS PRODUCTOS DE EJEMPLO
    console.log('\nüì¶ Creando productos de ejemplo...');
    
    // Obtener algunas categor√≠as para asignar productos
    const griferiaMonocomandoLavatorio = await db.collection('categories').findOne({ 
      slug: 'griferia-bano-monocomando-lavatorio' 
    });
    const griferiaCocina = await db.collection('categories').findOne({ 
      slug: 'griferia-cocina-monocomando' 
    });
    const plomeriaPVC = await db.collection('categories').findOne({ 
      slug: 'plomeria-tuberias-pvc' 
    });
    
    const sampleProducts = [
      {
        _id: new ObjectId(),
        name: 'Grifo Monocomando para Lavatorio Cromo',
        slug: 'grifo-monocomando-lavatorio-cromo',
        description: 'Grifo monocomando de alta calidad con acabado cromado',
        category: griferiaMonocomandoLavatorio?._id,
        brand: 'FV',
        sku: 'FV-001-CR',
        price: 15000,
        images: ['https://images.unsplash.com/photo-1584622650111-993a426fbf0a?w=400'],
        active: true,
        featured: true,
        stock: 25,
        attributes: [
          { name: 'Material', value: 'Lat√≥n cromado' },
          { name: 'Garant√≠a', value: '2 a√±os' }
        ],
        createdAt: new Date(),
        updatedAt: new Date()
      },
      {
        _id: new ObjectId(),
        name: 'Grifo de Cocina Extensible',
        slug: 'grifo-cocina-extensible',
        description: 'Grifo de cocina con ca√±o extensible y rociador',
        category: griferiaCocina?._id,
        brand: 'Hidromet',
        sku: 'HM-K001',
        price: 28000,
        images: ['https://images.unsplash.com/photo-1556909114-f6e7ad7d3136?w=400'],
        active: true,
        featured: false,
        stock: 15,
        attributes: [
          { name: 'Material', value: 'Acero inoxidable' },
          { name: 'Altura', value: '35 cm' }
        ],
        createdAt: new Date(),
        updatedAt: new Date()
      },
      {
        _id: new ObjectId(),
        name: 'Tuber√≠a PVC 110mm x 3m',
        slug: 'tuberia-pvc-110mm-3m',
        description: 'Tuber√≠a de PVC para desag√ºes de 110mm de di√°metro',
        category: plomeriaPVC?._id,
        brand: 'Tigre',
        sku: 'TG-PVC-110-3',
        price: 2500,
        images: ['https://images.unsplash.com/photo-1558618666-fbd68c1c3f90?w=400'],
        active: true,
        featured: false,
        stock: 100,
        attributes: [
          { name: 'Di√°metro', value: '110mm' },
          { name: 'Longitud', value: '3 metros' },
          { name: 'Presi√≥n m√°xima', value: '10 bar' }
        ],
        createdAt: new Date(),
        updatedAt: new Date()
      }
    ];
    
    await db.collection('products').insertMany(sampleProducts);
    console.log(`   ‚úÖ ${sampleProducts.length} productos de ejemplo creados`);
    
    // 5. ACTUALIZAR CONTADORES DE PRODUCTOS
    console.log('\nüìä Actualizando contadores...');
    
    const productCounts = await db.collection('products').aggregate([
      { $match: { active: true } },
      { $group: { _id: '$category', count: { $sum: 1 } } }
    ]).toArray();
    
    for (const count of productCounts) {
      if (count._id) {
        await db.collection('categories').updateOne(
          { _id: count._id },
          { 
            $set: { 
              productCount: count.count,
              totalProductCount: count.count,
              updatedAt: new Date()
            } 
          }
        );
      }
    }
    
    // 6. CREAR √çNDICES OPTIMIZADOS
    console.log('\nüîß Creando √≠ndices...');
    
    try {
      // √çndices para categories
      await db.collection('categories').createIndex({ parent: 1, level: 1, order: 1 });
      await db.collection('categories').createIndex({ slug: 1 }, { unique: true });
      await db.collection('categories').createIndex({ level: 1, active: 1 });
      await db.collection('categories').createIndex({ type: 1, active: 1 });
      
      // √çndices para products
      await db.collection('products').createIndex({ category: 1, active: 1 });
      await db.collection('products').createIndex({ brand: 1, active: 1 });
      await db.collection('products').createIndex({ sku: 1 }, { unique: true });
      await db.collection('products').createIndex({ active: 1, featured: 1 });
      await db.collection('products').createIndex({ name: 'text', description: 'text' });
      
      console.log('   ‚úÖ √çndices creados');
    } catch (error) {
      console.log('   ‚ö†Ô∏è  Algunos √≠ndices ya exist√≠an:', error.message);
    }
    
    // 7. VERIFICACI√ìN FINAL
    console.log('\nüîç Verificaci√≥n final...');
    
    const finalStats = {
      categories: await db.collection('categories').countDocuments(),
      level0: await db.collection('categories').countDocuments({ level: 0 }),
      level1: await db.collection('categories').countDocuments({ level: 1 }),
      level2: await db.collection('categories').countDocuments({ level: 2 }),
      level3: await db.collection('categories').countDocuments({ level: 3 }),
      products: await db.collection('products').countDocuments(),
      productsActive: await db.collection('products').countDocuments({ active: true })
    };
    
    console.log('üìà Estad√≠sticas finales:');
    console.log(`   Total categor√≠as: ${finalStats.categories}`);
    console.log(`   - Nivel 0 (principales): ${finalStats.level0}`);
    console.log(`   - Nivel 1: ${finalStats.level1}`);
    console.log(`   - Nivel 2: ${finalStats.level2}`);
    console.log(`   - Nivel 3: ${finalStats.level3}`);
    console.log(`   Total productos: ${finalStats.products} (${finalStats.productsActive} activos)`);
    
    // 8. PROBAR JER√ÅRQU√çA
    console.log('\nüß™ Probando jerarqu√≠a...');
    
    const CategoryService = require('../src/services/CategoryService');
    const categoryService = new CategoryService(db);
    
    // Probar categor√≠as principales
    const mainCategories = await categoryService.getMainCategories();
    console.log(`   Categor√≠as principales: ${mainCategories.length}`);
    mainCategories.forEach((cat, index) => {
      console.log(`      ${index + 1}. ${cat.name}`);
    });
    
    // Probar jerarqu√≠a de grifer√≠a
    const griferiaTree = await categoryService.getHierarchicalTree('griferia');
    console.log(`\n   Jerarqu√≠a de Grifer√≠a: ${griferiaTree.length} ramas`);
    griferiaTree.forEach((branch, index) => {
      console.log(`      ${index + 1}. ${branch.name} (${branch.children?.length || 0} hijos)`);
      if (branch.children) {
        branch.children.forEach((child, childIndex) => {
          console.log(`         ${childIndex + 1}. ${child.name} (${child.children?.length || 0} hijos)`);
        });
      }
    });
    
    console.log('\nüéâ LIMPIEZA Y SEEDING COMPLETADO');
    console.log('\n‚ú® Base de datos lista para usar con:');
    console.log('   - Estructura jer√°rquica limpia');
    console.log('   - Categor√≠as bien organizadas');
    console.log('   - Productos de ejemplo');
    console.log('   - √çndices optimizados');
    console.log(`   - Backup disponible: *_${timestamp}`);
    
  } catch (error) {
    console.error('\n‚ùå ERROR:', error.message);
    console.error(error.stack);
  } finally {
    if (client) {
      await client.close();
    }
  }
}

// Ejecutar
if (require.main === module) {
  cleanAndSeed()
    .then(() => {
      console.log('\n‚úÖ Proceso finalizado exitosamente');
      process.exit(0);
    })
    .catch((error) => {
      console.error('\nüí• Error fatal:', error.message);
      process.exit(1);
    });
}

module.exports = { cleanAndSeed };


