const { connectToDatabase, closeConnection } = require('../src/libs/mongoConnect');

/**
 * SCRIPT DE MIGRACI√ìN A MODELO UNIFICADO
 * 
 * Convierte el sistema actual (Category + Subcategory) al modelo unificado
 * 
 * INSTRUCCIONES:
 * 1. Aseg√∫rate de que MongoDB est√© ejecut√°ndose
 * 2. Ejecuta: node scripts/migrate-to-unified.js
 * 3. El script crear√° un backup autom√°tico antes de migrar
 * 
 * NOTA: Este script usa la misma configuraci√≥n de MongoDB que la aplicaci√≥n
 */

// Usar la base de datos desde las variables de entorno o la por defecto
const DB_NAME = process.env.DB_NAME || 'cyneth';

async function migrateToUnified() {
  let client = null;
  
  try {
    console.log('üîå Conectando a MongoDB usando configuraci√≥n de la aplicaci√≥n...');
    client = await connectToDatabase();
    const db = client.db(DB_NAME);
    
    console.log('üöÄ INICIANDO MIGRACI√ìN A MODELO UNIFICADO\n');
    
    // 1. VERIFICAR ESTADO ACTUAL
    console.log('üìä Verificando estado actual...');
    const categoriesCount = await db.collection('categories').countDocuments();
    const subcategoriesCount = await db.collection('subcategories').countDocuments();
    const productsCount = await db.collection('products').countDocuments();
    
    console.log(`   - Categor√≠as: ${categoriesCount}`);
    console.log(`   - Subcategor√≠as: ${subcategoriesCount}`);
    console.log(`   - Productos: ${productsCount}`);
    
    if (categoriesCount === 0 && subcategoriesCount === 0) {
      console.log('‚ö†Ô∏è  No hay datos para migrar. Saliendo...');
      return;
    }
    
    // 2. BACKUP DE DATOS ACTUALES
    console.log('\nüì¶ Creando backup...');
    const categoriesOld = await db.collection('categories').find({}).toArray();
    const subcategoriesOld = await db.collection('subcategories').find({}).toArray();
    const productsOld = await db.collection('products').find({}).toArray();
    
    // Crear colecciones de backup con timestamp
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    await db.collection(`categories_backup_${timestamp}`).insertMany(categoriesOld.length ? categoriesOld : [{ _placeholder: true }]);
    await db.collection(`subcategories_backup_${timestamp}`).insertMany(subcategoriesOld.length ? subcategoriesOld : [{ _placeholder: true }]);
    await db.collection(`products_backup_${timestamp}`).insertMany(productsOld.length ? productsOld : [{ _placeholder: true }]);
    
    console.log(`‚úÖ Backup creado con timestamp: ${timestamp}`);
    
    // 3. CREAR NUEVA COLECCI√ìN UNIFICADA
    console.log('\nüèóÔ∏è  Creando estructura unificada...');
    
    // Borrar colecci√≥n actual y recrear
    try {
      await db.collection('categories').drop();
      console.log('üóëÔ∏è  Colecci√≥n categories antigua eliminada');
    } catch (e) {
      console.log('‚ÑπÔ∏è  Colecci√≥n categories no exist√≠a');
    }
    
    const newCategories = [];
    
    // 3.1 Migrar categor√≠as principales (de categories)
    console.log('üìã Migrando categor√≠as principales...');
    categoriesOld.forEach(cat => {
      newCategories.push({
        _id: cat._id,
        name: cat.name,
        slug: cat.slug,
        description: cat.description || '',
        parent: null,
        level: 0,
        type: 'main',
        productCount: cat.productCount || 0,
        totalProductCount: cat.totalProductCount || cat.productCount || 0,
        order: cat.order || 0,
        active: cat.active !== false,
        createdAt: cat.createdAt || new Date(),
        updatedAt: new Date()
      });
    });
    
    // 3.2 Migrar subcategor√≠as (de subcategories)
    console.log('üìã Migrando subcategor√≠as...');
    
    // Crear un mapa para resolver referencias
    const categoryMap = new Map();
    categoriesOld.forEach(cat => {
      categoryMap.set(cat.slug, cat._id);
    });
    
    subcategoriesOld.forEach(sub => {
      // Encontrar la categor√≠a principal
      const mainCategoryId = categoryMap.get(sub.categorySlug);
      
      // Determinar el parent correcto
      let parentId = null;
      if (sub.parent) {
        parentId = sub.parent;
      } else if (mainCategoryId) {
        parentId = mainCategoryId;
      }
      
      newCategories.push({
        _id: sub._id,
        name: sub.name,
        slug: sub.slug,
        description: sub.description || '',
        parent: parentId,
        level: sub.level || (sub.parent ? 2 : 1), // Ajustar nivel
        type: 'sub',
        productCount: sub.productCount || 0,
        totalProductCount: sub.productCount || 0,
        order: 0,
        active: sub.active !== false,
        createdAt: sub.createdAt || new Date(),
        updatedAt: new Date()
      });
    });
    
    // Insertar categor√≠as unificadas
    if (newCategories.length > 0) {
      await db.collection('categories').insertMany(newCategories);
      console.log(`‚úÖ ${newCategories.length} categor√≠as unificadas creadas`);
    }
    
    // 4. CREAR √çNDICES OPTIMIZADOS
    console.log('\nüîß Creando √≠ndices optimizados...');
    try {
      await db.collection('categories').createIndex({ parent: 1, level: 1, order: 1, name: 1 });
      await db.collection('categories').createIndex({ type: 1, active: 1 });
      await db.collection('categories').createIndex({ slug: 1 }, { unique: true });
      await db.collection('categories').createIndex({ level: 1, active: 1 });
      console.log('‚úÖ √çndices de categor√≠as creados');
    } catch (error) {
      console.log('‚ö†Ô∏è  Algunos √≠ndices ya exist√≠an:', error.message);
    }
    
    // 5. MIGRAR PRODUCTOS
    console.log('\nüì¶ Migrando productos...');
    
    // Crear mapa de subcategor√≠as
    const subcategoryMap = new Map();
    subcategoriesOld.forEach(sub => {
      subcategoryMap.set(sub.slug, sub._id);
    });
    
    let migratedProducts = 0;
    for (const product of productsOld) {
      let categoryId = null;
      
      // Determinar la categor√≠a m√°s espec√≠fica
      if (product.subcategorySlug && subcategoryMap.has(product.subcategorySlug)) {
        categoryId = subcategoryMap.get(product.subcategorySlug);
      } else if (product.categorySlug && categoryMap.has(product.categorySlug)) {
        categoryId = categoryMap.get(product.categorySlug);
      }
      
      if (categoryId) {
        // Actualizar producto con nueva estructura
        await db.collection('products').updateOne(
          { _id: product._id },
          {
            $set: {
              category: categoryId,
              updatedAt: new Date()
            },
            $unset: {
              categorySlug: 1,
              subcategory: 1,
              subcategorySlug: 1,
              categoryPath: 1,
              categoryPathNames: 1,
              categoryBreadcrumb: 1
            }
          }
        );
        migratedProducts++;
      } else {
        console.log(`‚ö†Ô∏è  Producto sin categor√≠a v√°lida: ${product.name}`);
      }
    }
    console.log(`‚úÖ ${migratedProducts}/${productsOld.length} productos migrados`);
    
    // 6. CREAR √çNDICES DE PRODUCTOS
    console.log('\nüîß Creando √≠ndices de productos...');
    try {
      await db.collection('products').createIndex({ category: 1, active: 1 });
      await db.collection('products').createIndex({ brand: 1, active: 1 });
      await db.collection('products').createIndex({ sku: 1 }, { unique: true });
      await db.collection('products').createIndex({ active: 1, featured: 1 });
      console.log('‚úÖ √çndices de productos creados');
    } catch (error) {
      console.log('‚ö†Ô∏è  Algunos √≠ndices ya exist√≠an:', error.message);
    }
    
    // 7. ACTUALIZAR CONTADORES
    console.log('\nüìä Actualizando contadores...');
    const productCounts = await db.collection('products').aggregate([
      { $match: { active: true } },
      { $group: { _id: '$category', count: { $sum: 1 } } }
    ]).toArray();
    
    for (const count of productCounts) {
      if (count._id) {
        await db.collection('categories').updateOne(
          { _id: count._id },
          { 
            $set: { 
              productCount: count.count,
              totalProductCount: count.count, // Por ahora igual, luego se puede calcular recursivo
              updatedAt: new Date()
            } 
          }
        );
      }
    }
    console.log('‚úÖ Contadores actualizados');
    
    // 8. VERIFICACI√ìN FINAL
    console.log('\nüîç Verificando migraci√≥n...');
    const finalCategories = await db.collection('categories').find({}).toArray();
    const finalProducts = await db.collection('products').find({}).toArray();
    
    const mainCategories = finalCategories.filter(c => c.level === 0);
    const subCategories = finalCategories.filter(c => c.level > 0);
    const productsWithCategory = finalProducts.filter(p => p.category);
    
    console.log(`üìä RESULTADO FINAL:`);
    console.log(`   - Categor√≠as principales: ${mainCategories.length}`);
    console.log(`   - Subcategor√≠as: ${subCategories.length}`);
    console.log(`   - Total categor√≠as: ${finalCategories.length}`);
    console.log(`   - Productos con categor√≠a: ${productsWithCategory.length}/${finalProducts.length}`);
    
    // 9. ELIMINAR COLECCI√ìN OBSOLETA
    console.log('\nüóëÔ∏è  Limpiando colecciones obsoletas...');
    try {
      await db.collection('subcategories').drop();
      console.log('‚úÖ Colecci√≥n subcategories eliminada');
    } catch (e) {
      console.log('‚ÑπÔ∏è  Colecci√≥n subcategories no exist√≠a');
    }
    
    console.log('\nüéâ MIGRACI√ìN COMPLETADA EXITOSAMENTE');
    console.log('\nüí° PR√ìXIMOS PASOS:');
    console.log('   1. Reiniciar la aplicaci√≥n Next.js');
    console.log('   2. Probar el cat√°logo y filtros');
    console.log('   3. Verificar formulario de productos en admin');
    console.log(`   4. Si todo funciona, eliminar colecciones backup_${timestamp}`);
    
  } catch (error) {
    console.error('\n‚ùå ERROR EN MIGRACI√ìN:', error.message);
    console.log('\nüîÑ Para revertir:');
    console.log('   1. Restaurar desde las colecciones *_backup_*');
    console.log('   2. Recrear √≠ndices originales');
    console.log('   3. Revisar logs para identificar el problema');
  } finally {
    if (client) {
      await closeConnection();
    }
  }
}

// Verificar argumentos de l√≠nea de comandos
if (process.argv.includes('--help') || process.argv.includes('-h')) {
  console.log(`
üîÑ SCRIPT DE MIGRACI√ìN A MODELO UNIFICADO

Uso: node scripts/migrate-to-unified.js [opciones]

Opciones:
  --help, -h    Mostrar esta ayuda
  
Variables de entorno:
  MONGODB_URI   URI de conexi√≥n a MongoDB (se usa la de .env o default)
  DB_NAME       Nombre de la base de datos (default: cyneth)
  
Ejemplo:
  DB_NAME=cyneth node scripts/migrate-to-unified.js
  
Nota: El script usa autom√°ticamente la configuraci√≥n de MongoDB de src/libs/mongoConnect.js
  `);
  process.exit(0);
}

// Ejecutar migraci√≥n
if (require.main === module) {
  migrateToUnified()
    .then(() => {
      console.log('\n‚ú® Proceso finalizado');
      process.exit(0);
    })
    .catch((error) => {
      console.error('\nüí• Error fatal:', error.message);
      process.exit(1);
    });
}

module.exports = { migrateToUnified };
